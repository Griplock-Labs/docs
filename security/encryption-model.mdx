GripLock uses authenticated encryption to protect wallet shares, session data, and recovery objects.

In V2, all encryption uses **AEAD constructions** — ensuring both confidentiality and integrity in a single operation. There are no bare ciphers, no unauthenticated encryption, and no use of SHA-256 as a key derivation function.

This page describes the cryptographic primitives, data structures, and critical rules that define GripLock's encryption model.

---

## Cryptographic Primitives

GripLock V2 uses the following primitives:

| Function | Algorithm | Notes |
|----------|-----------|-------|
| **KDF** | Argon2id (64 MiB, 3 iters, parallelism 1) | scrypt as fallback |
| **AEAD** | XChaCha20-Poly1305 (preferred) | 24-byte nonce, built-in auth tag |
| **AEAD (alt)** | AES-256-GCM | Acceptable where XChaCha20 is unavailable |
| **Hash** | SHA-256 | Fingerprints and non-secret metadata only |
| **Secret Sharing** | Shamir 2-of-3 | Threshold reconstruction of MASTER_SECRET |

SHA-256 is used only for non-secret purposes: content fingerprints, NFC UID hashing, and integrity checks on public metadata. It is never used for key derivation.

---

## AEAD Encryption

All encryption operations in GripLock V2 use **Authenticated Encryption with Associated Data (AEAD)**.

AEAD provides:
- **Confidentiality** — ciphertext cannot be read without the key
- **Integrity** — any modification to ciphertext is detected
- **Authentication** — the auth tag proves the ciphertext was produced by a holder of the key

XChaCha20-Poly1305 is preferred because its 24-byte nonce eliminates practical nonce collision risk, even with random nonce generation. AES-256-GCM is acceptable on platforms where XChaCha20 is not available.

Bare encryption (without authentication) is never used.

---

## EncryptedBlob Structure

Every encrypted artifact in GripLock V2 conforms to the EncryptedBlob format:

```
EncryptedBlob {
  version:    uint8           // Schema version (currently 1)
  aead:       string          // Algorithm identifier ("xchacha20poly1305" | "aes256gcm")
  nonce:      bytes           // 24 bytes (XChaCha20) or 12 bytes (AES-GCM)
  ciphertext: bytes           // Encrypted payload with appended auth tag
}
```

The auth tag is included within the ciphertext field. Decryption fails atomically if the tag does not verify — there is no partial decryption.

---

## KdfEnvelope Structure

Key derivation parameters are stored alongside encrypted shares in a KdfEnvelope:

```
KdfEnvelope {
  version:    uint8           // Schema version (currently 1)
  kdf:        string          // Algorithm identifier ("argon2id" | "scrypt")
  params:     object          // Algorithm-specific parameters (mem, iters, parallelism)
  salt:       bytes           // 16–32 random bytes, generated at provisioning
  pinPolicy:  string          // "pin_only" | "secret_only" | "maximum"
}
```

The salt is generated from a cryptographically secure random source and is never reused across key derivations. The KdfEnvelope travels with the encrypted share so that any device can re-derive K_user given the correct credentials.

---

## Recovery Object Encryption

Each recovery share is encrypted with a different key and stored in a different location:

| Share | Encrypted With | Stored At |
|-------|---------------|-----------|
| **Share A** | K_user (Argon2id-derived) | Google Drive (DriveRecoveryObject) |
| **Share B** | K_dev (Secure Enclave / Keystore) | Device local storage (DeviceRecoveryObject) |
| **Share C** | Passkey-derived key | Passkey provider (PasskeyWrappedShare) |

**DriveRecoveryObject** contains:
- Schema identifier: `griplock.recovery.v2`
- Wallet ID
- Share A as an EncryptedBlob
- KdfEnvelope for K_user re-derivation
- NFC metadata (uidHash only — never the raw UID)
- Passkey binding reference

**DeviceRecoveryObject** contains:
- Share B as an EncryptedBlob (encrypted with K_dev)
- Optional encrypted session cache

**PasskeyWrappedShare** contains:
- Share C as an EncryptedBlob (encrypted with a key derived from the passkey ceremony)

---

## What Encryption Protects

Encryption in GripLock V2 protects:
- Shamir shares at rest (Drive, Device, Passkey)
- Session cache in SecureStore
- MASTER_SECRET in memory during active sessions
- Communication between client components during signing

Encryption does not replace physical intent requirements. It complements the session-based security model.

---

## What Is Never Done

GripLock V2 enforces explicit cryptographic prohibitions:

- **NEVER** use `SHA256(PIN + ...)` as a key derivation function — use Argon2id or scrypt
- **NEVER** use the NFC UID as an encryption key or key derivation input
- **NEVER** use unauthenticated encryption (no bare AES-CBC, no XOR ciphers)
- **NEVER** reuse nonces across encryption operations
- **NEVER** store encryption keys on GripLock servers

These are architectural invariants enforced at the protocol level.

---

## No Server-Side Decryption

GripLock servers cannot decrypt any user data.

Servers act as:
- Transport layers for encrypted recovery objects
- Coordination endpoints for session establishment

They never hold decryption keys, plaintext shares, or MASTER_SECRET material. Decryption occurs exclusively on the user's device.

---

> **Summary**
> GripLock V2 encrypts all sensitive data with AEAD (XChaCha20-Poly1305 or AES-256-GCM).
> Keys are derived via Argon2id — never SHA-256. Every encrypted artifact carries its own auth tag.
> GripLock servers cannot decrypt anything. Encryption protects shares at rest, sessions in transit, and secrets in memory.

---

<Info>
This page describes **GripLock V2** architecture. See the [Changelog](/changelog) for version history and V1 comparison.
</Info>
