---
title: "WebSocket API"
description: "WebSocket signaling server message reference"
---

# WebSocket API

The GRIPLOCK signaling server uses WebSocket for real-time communication during connection establishment.

## Connection

### Endpoint

<Tabs>
  <Tab title="Production">
    ```
    wss://app.griplock.io/ws
    ```
  </Tab>
  <Tab title="Development">
    ```
    ws://localhost:5000/ws
    ```
  </Tab>
</Tabs>

### Connection Example

```typescript
const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
const wsUrl = `${wsProtocol}//${window.location.host}/ws`;

const ws = new WebSocket(wsUrl);

ws.onopen = () => {
  console.log('Connected to signaling server');
};

ws.onclose = (event) => {
  console.log(`Disconnected: ${event.code} ${event.reason}`);
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};
```

## Message Format

All messages are JSON-encoded with a `type` field:

```typescript
interface WSMessage {
  type: string;
  [key: string]: unknown;
}
```

## Dashboard Messages

### register_dashboard

Registers the dashboard client with a session.

**Direction:** Dashboard → Server

```typescript
{
  type: 'register_dashboard',
  sessionId: string  // Unique session identifier
}
```

**Example:**

```json
{
  "type": "register_dashboard",
  "sessionId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}
```

**Server Response:** None (success is implicit)

**Errors:** Connection closed if session already has a dashboard

---

## Mobile Messages

### register_mobile

Registers the mobile client with an existing session.

**Direction:** Mobile → Server

```typescript
{
  type: 'register_mobile',
  sessionId: string  // Session ID from QR code
}
```

**Example:**

```json
{
  "type": "register_mobile",
  "sessionId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890"
}
```

**Server Action:** Notifies dashboard via `mobile_connected`

---

### answer

Sends WebRTC answer SDP to complete signaling.

**Direction:** Mobile → Server → Dashboard

```typescript
{
  type: 'answer',
  sessionId: string,
  sdp: RTCSessionDescriptionInit,
  pk: string  // Mobile public key (hex)
}
```

**Example:**

```json
{
  "type": "answer",
  "sessionId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "sdp": {
    "type": "answer",
    "sdp": "v=0\r\no=- 123456789..."
  },
  "pk": "a1b2c3d4e5f6..."
}
```

---

### ice_candidate

Exchanges ICE candidates for NAT traversal.

**Direction:** Bidirectional (Mobile ↔ Server ↔ Dashboard)

```typescript
{
  type: 'ice_candidate',
  sessionId: string,
  candidate: RTCIceCandidateInit
}
```

**Example:**

```json
{
  "type": "ice_candidate",
  "sessionId": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "candidate": {
    "candidate": "candidate:1 1 UDP 2122252543...",
    "sdpMid": "0",
    "sdpMLineIndex": 0
  }
}
```

---

### encrypted_credentials

Sends encrypted wallet credentials via WebSocket fallback.

**Direction:** Mobile → Server → Dashboard

<Warning>
  This message is typically sent via WebRTC DataChannel for better security. WebSocket relay is a fallback mechanism.
</Warning>

```typescript
{
  type: 'encrypted_credentials',
  sessionId: string,
  nonce: string,      // AES-GCM nonce (hex)
  ciphertext: string  // Encrypted payload (hex)
}
```

---

## Server Messages

### mobile_connected

Notifies the dashboard that a mobile client joined.

**Direction:** Server → Dashboard

```typescript
{
  type: 'mobile_connected'
}
```

**Dashboard Action:** Prepare to receive WebRTC answer

---

### answer (relayed)

Relays the WebRTC answer from mobile to dashboard.

**Direction:** Server → Dashboard

```typescript
{
  type: 'answer',
  sdp: RTCSessionDescriptionInit,
  pk: string  // Mobile public key (hex)
}
```

---

### ice_candidate (relayed)

Relays ICE candidates between peers.

**Direction:** Server → Peer

```typescript
{
  type: 'ice_candidate',
  candidate: RTCIceCandidateInit
}
```

---

### error

Reports an error to the client.

**Direction:** Server → Client

```typescript
{
  type: 'error',
  message: string
}
```

**Example:**

```json
{
  "type": "error",
  "message": "Session not found"
}
```

## Session Management

### Session Creation

Sessions are created implicitly when a dashboard registers:

```typescript
// Server-side (simplified)
if (message.type === 'register_dashboard') {
  sessions.set(message.sessionId, {
    dashboard: ws,
    mobile: null
  });
}
```

### Session Cleanup

Sessions are cleaned up when:

1. Dashboard disconnects
2. Mobile disconnects
3. Connection timeout (no activity)

```typescript
ws.on('close', () => {
  if (currentSessionId && sessions.has(currentSessionId)) {
    const session = sessions.get(currentSessionId);
    if (clientType === 'dashboard') {
      sessions.delete(currentSessionId);
    } else if (clientType === 'mobile') {
      session.mobile = null;
    }
  }
});
```

## Error Codes

| Code | Message | Cause |
|------|---------|-------|
| `session_not_found` | Session does not exist | Invalid session ID |
| `session_full` | Session already has a mobile | Duplicate mobile connection |
| `invalid_message` | Message format invalid | Malformed JSON or missing fields |
| `peer_disconnected` | Peer client disconnected | Dashboard or mobile closed |

## Rate Limiting

The signaling server implements basic rate limiting:

| Limit | Value | Scope |
|-------|-------|-------|
| Messages per second | 10 | Per connection |
| Connections per IP | 50 | Per IP address |
| Message size | 64 KB | Per message |

## Best Practices

<CardGroup cols={2}>
  <Card title="Reconnection" icon="rotate">
    Implement exponential backoff for reconnection attempts
  </Card>
  <Card title="Heartbeat" icon="heart-pulse">
    Send periodic ping messages to detect stale connections
  </Card>
  <Card title="Timeout" icon="clock">
    Set connection timeout for unresponsive peers
  </Card>
  <Card title="Cleanup" icon="broom">
    Close WebSocket after P2P channel established
  </Card>
</CardGroup>

## Example: Full Flow

```typescript
// Dashboard
const ws = new WebSocket(wsUrl);

ws.onopen = () => {
  ws.send(JSON.stringify({
    type: 'register_dashboard',
    sessionId: mySessionId
  }));
};

ws.onmessage = (event) => {
  const msg = JSON.parse(event.data);
  
  if (msg.type === 'mobile_connected') {
    console.log('Mobile joined, awaiting answer...');
  }
  
  if (msg.type === 'answer') {
    await pc.setRemoteDescription(new RTCSessionDescription(msg.sdp));
    // Store mobile public key for encryption
    mobilePublicKey = hexToBytes(msg.pk);
  }
  
  if (msg.type === 'ice_candidate') {
    await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
  }
};

// Mobile
ws.onopen = () => {
  ws.send(JSON.stringify({
    type: 'register_mobile',
    sessionId: sessionIdFromQR
  }));
  
  // Send answer after processing offer
  ws.send(JSON.stringify({
    type: 'answer',
    sessionId: sessionIdFromQR,
    sdp: myAnswer,
    pk: publicKeyToHex(myPublicKey)
  }));
};
```

## Next Steps

<CardGroup cols={2}>
  <Card title="Payload Formats" icon="file-code" href="/api-reference/payloads">
    Data structure specifications
  </Card>
  <Card title="Security" icon="shield" href="/security/encryption">
    Encryption implementation details
  </Card>
</CardGroup>
